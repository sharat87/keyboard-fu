function readKeyCombo(e, preventDefault) {

    var keyChar = "";

    var keyCodes = { ESC: 27, backspace: 8, deleteKey: 46, enter: 13, space: 32, shiftKey: 16, f1: 112, f12: 123};
    var keyNames = { 37: "left", 38: "up", 39: "right", 40: "down" }

    // This is a mapping of the incorrect keyIdentifiers generated by Webkit on Windows during keydown events to
    // the correct identifiers, which are correctly generated on Mac. We require this mapping to properly handle
    // these keys on Windows. See https://bugs.webkit.org/show_bug.cgi?id=19906 for more details.
    var keyIdentifierCorrectionMap = {
        "U+00C0": ["U+0060", "U+007E"], // `~
        "U+00BD": ["U+002D", "U+005F"], // -_
        "U+00BB": ["U+003D", "U+002B"], // =+
        "U+00DB": ["U+005B", "U+007B"], // [{
        "U+00DD": ["U+005D", "U+007D"], // ]}
        "U+00DC": ["U+005C", "U+007C"], // \|
        "U+00BA": ["U+003B", "U+003A"], // ;:
        "U+00DE": ["U+0027", "U+0022"], // '"
        "U+00BC": ["U+002C", "U+003C"], // ,<
        "U+00BE": ["U+002E", "U+003E"], // .>
        "U+00BF": ["U+002F", "U+003F"] // /?
    };

    var platform;
    if (navigator.userAgent.indexOf("Mac") != -1)
        platform = "Mac";
    else if (navigator.userAgent.indexOf("Linux") != -1)
        platform = "Linux";
    else
        platform = "Windows";

    if (e.type == 'keydown') {

        // handle modifiers being pressed.don't handle shiftKey alone (to avoid / being interpreted as ?
        if (e.metaKey && e.keyCode > 31 || e.ctrlKey && e.keyCode > 31 || e.altKey && e.keyCode > 31) {

            preventDefault && e.preventDefault();

            // Not a letter
            if (e.keyIdentifier.slice(0, 2) != "U+") {
                // Named key
                if (keyNames[e.keyCode]) {
                    return keyNames[e.keyCode];
                }
                // F-key
                if (e.keyCode >= keyCodes.f1 && e.keyCode <= keyCodes.f12) {
                    return "f" + (1 + e.keyCode - keyCodes.f1);
                }
                return "";
            }
            var keyIdentifier = e.keyIdentifier;
            // On Windows, the keyIdentifiers for non-letter keys are incorrect. See
            // https://bugs.webkit.org/show_bug.cgi?id=19906 for more details.
            if ((platform == "Windows" || platform == "Linux") && keyIdentifierCorrectionMap[keyIdentifier]) {
                correctedIdentifiers = keyIdentifierCorrectionMap[keyIdentifier];
                keyIdentifier = e.shiftKey ? correctedIdentifiers[0] : correctedIdentifiers[1];
            }
            var unicodeKeyInHex = "0x" + keyIdentifier.substring(2);

            keyChar = String.fromCharCode(parseInt(unicodeKeyInHex)).toLowerCase();

            if (keyChar != "") { // Again, ignore just modifiers. Maybe this should replace the keyCode > 31 condition.
                var modifiers = [];

                if (e.shiftKey)
                    keyChar = keyChar.toUpperCase();
                if (e.metaKey)
                    modifiers.push("M");
                if (e.ctrlKey)
                    modifiers.push("C");
                if (e.altKey)
                    modifiers.push("A");

                keyChar = modifiers.join('-') + (modifiers.length ? '-' : '') + keyChar;

                if (modifiers.length > 0 || keyChar.length > 1)
                    keyChar = "<" + keyChar + ">";

            }
        }

    } else if (e.type == 'keypress') {

        // Ignore modifier keys by themselves.
        if (e.keyCode > 31) {
            keyChar = String.fromCharCode(e.charCode);
        }

    }

    console.info('key char', keyChar);
    return keyChar;

}

// Gives a string that is a regex representation of the given glob pattern
function globToRegex(line) {
    console.info("got line [" + line + "]");
    line = $.trim(line);
    
    var sb = [];
    
    // Remove beginning and ending * globs because they're useless
    if (line.length > 1 && line[0] === "*") {
        line = line.substring(1);
    }
    if (line.length > 1 && line[line.length-1] === "*") {
        line = line.substring(0, line.length - 1);
    }
    
    var i = 0, len = line.length,
        escaping = false, inCurlies = 0;
    
    while (i < len) {
        var currentChar = line[i++];
        switch (currentChar) {
        case '*':
            sb.push(escaping ? "\\*" : ".*");
            escaping = false;
            break;
        case '?':
            sb.push(escaping ? "\\?" : ".");
            escaping = false;
            break;
        case '.':
        case '(':
        case ')':
        case '+':
        case '|':
        case '^':
        case '$':
        case '@':
        case '%':
            sb.push('\\');
            sb.push(currentChar);
            escaping = false;
            break;
        case '\\':
            escaping && sb.push("\\\\");
            escaping = !escaping;
            break;
        case '{':
            sb.push(escaping ? '\\{' : '(');
            if (!escaping) {
                inCurlies++;
            }
            escaping = false;
            break;
        case '}':
            if (inCurlies > 0 && !escaping) {
                sb.push(')');
                inCurlies--;
            } else if (escaping) {
                sb.push("\\}");
            } else {
                sb.push("}");
            }
            escaping = false;
            break;
        case ',':
            if (inCurlies > 0 && !escaping) {
                sb.push('|');
            } else if (escaping) {
                sb.push("\\,");
            } else {
                sb.push(",");
            }
            break;
        default:
            escaping = false;
            sb.push(currentChar);
        }
    }
    return sb.join('');
}
